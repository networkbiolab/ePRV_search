################################# Run - WGCNA############################################## ========================== WGCNA Pipeline ================================library(DESeq2)library(WGCNA)library(limma)library(pheatmap)library(igraph)library(gplots)library(topGO)enableWGCNAThreads(nThreads = 12)run_wgcna_pipeline <- function(dds, trait_labels, eprv_ids_file, gene2go_file,                               output_prefix = "TomatoWGCNA",                               minEdgeWeight = 0.4,                               mergeCutHeight = 0.4) {    # -------------------- Preprocessing --------------------  # Filter genes with low expression  dds <- dds[rowSums(counts(dds) >= 10) >= 18, ]    # Variance stabilizing transformation  vst_data <- vst(dds, blind = FALSE)  datExpr <- assay(vst_data)  colnames(datExpr) <- trait_labels    # Sample clustering to detect outliers  pdf(paste0(output_prefix, "_sample_clustering.pdf"))  plot(hclust(dist(t(datExpr))), main = "Sample Clustering")  dev.off()    # Remove genes with low variability  gene_var <- apply(datExpr, 1, sd)  datExpr <- datExpr[gene_var > quantile(gene_var, 0.25), ]    # Save original gene IDs before transposition  gene_ids <- rownames(datExpr)    # Transpose for WGCNA  datExpr <- t(datExpr)    # -------------------- Soft-threshold --------------------  powers <- 1:20  sft <- pickSoftThreshold(datExpr, powerVector = powers, verbose = 0)  softPower <- min(sft$fitIndices[sft$fitIndices[, 2] > 0.8, 1], na.rm = TRUE)  if (is.infinite(softPower)) softPower <- which.max(sft$fitIndices[, 2])    pdf(paste0(output_prefix, "_SoftThreshold.pdf"))  par(mfrow = c(1, 2))  plot(sft$fitIndices[,1], sft$fitIndices[,2], type = "b", pch = 19,        xlab = "Soft Threshold", ylab = "Scale-Free Topology Fit",       main = paste("Scale-Free Topology Fit (Power=", softPower, ")", sep=""))  abline(h = 0.8, col = "red")  plot(sft$fitIndices[,1], sft$fitIndices[,5], type = "b", pch = 19,       xlab = "Soft Threshold", ylab = "Mean Connectivity",       main = "Mean Connectivity")  dev.off()    # -------------------- Network Construction --------------------  adjacency <- adjacency(datExpr, power = softPower)  TOM <- TOMsimilarity(adjacency)  dissTOM <- 1 - TOM  geneTree <- hclust(as.dist(dissTOM), method = "average")    dynamicMods <- cutreeDynamic(dendro = geneTree, distM = dissTOM,                               deepSplit = 2, minClusterSize = 30)  moduleColors <- labels2colors(dynamicMods)    # Create a mapping between gene IDs and module colors  gene_to_module <- data.frame(    GeneID = colnames(datExpr),    ModuleColor = moduleColors,    stringsAsFactors = FALSE  )    # -------------------- Eigengene clustering --------------------  ME_unmerged <- moduleEigengenes(datExpr, colors = moduleColors)$eigengenes  METree <- hclust(as.dist(1 - cor(ME_unmerged)), method = "average")  pdf(paste0(output_prefix, "_Clustering_of_Module_Eigengenes.pdf"))  plot(METree, main = "Clustering of Module Eigengenes (Pre-Merge)", xlab = "", sub = "")  abline(h = mergeCutHeight, col = "red")  dev.off()    # -------------------- Merge Modules --------------------  merged <- mergeCloseModules(datExpr, moduleColors, cutHeight = mergeCutHeight, verbose = 3)  moduleColors <- merged$colors  MEs <- orderMEs(merged$newMEs)    # Update gene to module mapping after merging  gene_to_module$ModuleColor <- moduleColors    # -------------------- Dendrogram of merged modules --------------------  pdf(paste0(output_prefix, "_DendrogramAndColors_Merged.pdf"))  plotDendroAndColors(geneTree, moduleColors, "Merged Module Colors",                      dendroLabels = FALSE, hang = 0.03,                      addGuide = TRUE, guideHang = 0.05)  dev.off()    # -------------------- Module-trait relationships --------------------  sampleTraits <- data.frame(Stage = trait_labels)  design <- model.matrix(~ 0 + sampleTraits$Stage)  colnames(design) <- levels(sampleTraits$Stage)    cor_matrix <- cor(MEs, design)  p_matrix <- corPvalueStudent(cor_matrix, ncol(datExpr))  textMatrix <- paste(signif(cor_matrix, 2), "\n(", signif(p_matrix, 1), ")", sep = "")    stageLabels <- levels(sampleTraits$Stage)  customStageLabels <- c("Anthesis", "5DPA", "10DPA", "20DPA", "30DPA",                         "MG", "Br", "Pk", "LR", "RR")    pdf(paste0(output_prefix, "_ModuleTraitHeatmap.pdf"))  labeledHeatmap(Matrix = cor_matrix, xLabels = customStageLabels,                 yLabels = names(MEs), ySymbols = names(MEs),                 colorLabels = FALSE, colors = blueWhiteRed(50),                 textMatrix = textMatrix, setStdMargins = FALSE,                 cex.text = 0.5, zlim = c(-1,1), main = "Module-Trait Relationships")  dev.off()    # MODIFIED SECTION: Create correlation+pvalue paired values  trait_corr_df <- data.frame(Module = rownames(cor_matrix))    # Add combined correlation and p-value values  for (i in 1:length(customStageLabels)) {    trait_corr_df[[customStageLabels[i]]] <- paste(      signif(cor_matrix[, i], 3),  # Correlation value      signif(p_matrix[, i], 3),    # p-value      sep = ","    )  }    # Save as tab-separated text file instead of CSV  write.table(trait_corr_df,               paste0(output_prefix, "_ModuleTrait_correlations.txt"),               sep = "\t", row.names = FALSE, quote = FALSE)    # -------------------- Module Membership --------------------  kme <- signedKME(datExpr, MEs)  colnames(kme) <- gsub("^kME", "kME", colnames(kme))    # Add gene IDs to kme dataframe for easier tracking  kme_with_genes <- kme    # Load ePRV IDs  eprv_ids <- read.csv(eprv_ids_file, header = FALSE)$V1    # Extract kME values for ePRV genes  eprv_kme <- kme[rownames(kme) %in% eprv_ids, , drop = FALSE]  write.csv(eprv_kme, paste0(output_prefix, "_ePRV_kME.csv"))    # Find which modules contain ePRV genes (FIXED)  eprv_modules <- unique(gene_to_module$ModuleColor[gene_to_module$GeneID %in% eprv_ids])    # Extract all genes in modules that contain ePRV genes (FIXED)  all_genes_in_eprv_modules <- gene_to_module$GeneID[gene_to_module$ModuleColor %in% eprv_modules]  kme_subset <- kme[rownames(kme) %in% all_genes_in_eprv_modules, , drop = FALSE]  write.csv(kme_subset, paste0(output_prefix, "_kME_ePRV_modules_allgenes.csv"))    # -------------------- Create gene-module table (NEW) --------------------  # Generate a table with genes by module  module_list <- unique(moduleColors)  gene_module_table <- data.frame(GeneID = colnames(datExpr))    for (mod in module_list) {    gene_module_table[, mod] <- as.integer(moduleColors == mod)  }    write.table(gene_module_table, paste0(output_prefix, "_genes_by_module.txt"),               sep = "\t", row.names = FALSE, quote = FALSE)    # -------------------- Cytoscape Export --------------------  TOM_filtered <- TOM  TOM_filtered[TOM_filtered < minEdgeWeight] <- 0  net <- graph_from_adjacency_matrix(TOM_filtered, mode = "undirected", weighted = TRUE, diag = FALSE)  V(net)$name <- colnames(datExpr)    el <- as_edgelist(net)  weights <- E(net)$weight  edge_data <- data.frame(from = el[,1], to = el[,2], weight = weights)  edge_data <- edge_data[edge_data$weight >= minEdgeWeight, ]  write.table(edge_data, paste0(output_prefix, "_Cytoscape_edgeList_filtered.txt"),              sep = "\t", row.names = FALSE)    # Fix node attributes (FIXED)  node_data <- data.frame(    GeneID = colnames(datExpr),    ModuleColor = moduleColors,    Max_kME = apply(kme, 1, max),    ePRV = colnames(datExpr) %in% eprv_ids  )  write.table(node_data, paste0(output_prefix, "_Cytoscape_nodeAttributes.txt"),              sep = "\t", row.names = FALSE, quote = FALSE)    # -------------------- Heatmap --------------------  pdf(paste0(output_prefix, "_ePRV_kME_heatmap.pdf"))  heatmap.2(as.matrix(eprv_kme), scale = "row", trace = "none", dendrogram = "row",            col = bluered(75), key = TRUE, keysize = 1.5,            labRow = rownames(eprv_kme), margins = c(8,6),            cexRow = 0.3,            main = "ePRV Module Membership (kME)")  dev.off()    # -------------------- GO Enrichment --------------------  gene2go <- read.table(gene2go_file, header = FALSE, sep = "\t", stringsAsFactors = FALSE)  colnames(gene2go) <- c("gene", "GO")    # Clean GO terms to handle comma-separated format  gene2go$GO <- gsub(" ", "", gene2go$GO)  gene2GOmap <- strsplit(gene2go$GO, ",")  names(gene2GOmap) <- gene2go$gene    # Make sure to use Solyc IDs for GO enrichment  geneList <- function(modGenes, universe_genes) {    # Create a factor of 0 and 1 indicating if gene is in module    geneVec <- factor(as.integer(universe_genes %in% modGenes))    names(geneVec) <- universe_genes    return(geneVec)  }    # Define universe as all genes in the analysis  universe_genes <- colnames(datExpr)    # Filter universe to only include genes found in the gene2go mapping  universe_genes_in_GO <- intersect(universe_genes, gene2go$gene)    if (length(universe_genes_in_GO) == 0) {    warning("No genes in the universe match gene IDs in the GO mapping file. Check gene ID format.")  } else {    ontologies <- c("BP", "MF", "CC")        for (mod in unique(moduleColors)) {      if (mod == "grey") next            # Get genes in this module      modGenes <- colnames(datExpr)[moduleColors == mod]            # Filter to genes found in GO database      modGenes_in_GO <- intersect(modGenes, gene2go$gene)            if (length(modGenes_in_GO) < 3) {        message(paste0("Skipping GO for module ", mod, " - too few genes (",                        length(modGenes_in_GO), ") with GO annotations"))        next      }            # Create gene vector for topGO      geneFac <- geneList(modGenes_in_GO, universe_genes_in_GO)            for (ont in ontologies) {        if (length(unique(geneFac)) < 2) next                message(paste0("Running GO for module ", mod, " [", ont, "] with ",                        sum(geneFac == 1), " genes"))                tryCatch({          GOdata <- new("topGOdata",                        ontology = ont,                        allGenes = geneFac,                        annot = annFUN.gene2GO,                        gene2GO = gene2GOmap,                        nodeSize = 3)                    # Skip if too few genes          if (numGenes(GOdata) < 3) {            message("  Too few genes with GO annotations in this category")            next          }                    resultFisher <- runTest(GOdata, algorithm = "classic", statistic = "fisher")          tab <- GenTable(GOdata, classicFisher = resultFisher,                          orderBy = "classicFisher", topNodes = 30)                    # Only output if we have results          if (nrow(tab) > 0) {            write.csv(tab, paste0(output_prefix, "_GO_", ont, "_Module_", mod, ".csv"),                       row.names = FALSE)                        # Create barplot of GO enrichment            pdf(paste0(output_prefix, "_GO_", ont, "_Module_", mod, "_barplot.pdf"))            barplot(-log10(as.numeric(tab$classicFisher)),                    names.arg = tab$Term, las = 2, cex.names = 0.6,                    col = "steelblue",                    main = paste("GO", ont, "Module", mod),                    ylab = "-log10(Fisher p-value)")            dev.off()          } else {            message("  No significant GO terms found")          }        }, error = function(e) {          message(paste0("Error in GO enrichment for module ", mod, " [", ont, "]: ", e$message))        })      }    }  }    # -------------------- NEW: GO Enrichment for Solyc genes connected to ePRV --------------------  message("Starting GO enrichment analysis for Solyc genes connected to ePRV genes")    # Read the edge list file that was generated earlier  edge_list <- tryCatch({    read.table(paste0(output_prefix, "_Cytoscape_edgeList_filtered.txt"),                sep = "\t", header = TRUE, stringsAsFactors = FALSE)  }, error = function(e) {    message("Error reading edge list file: ", e$message)    return(NULL)  })    if (!is.null(edge_list)) {    # Filter edges to only include connections between ePRV and Solyc genes    # Pattern matching to identify ePRV and Solyc genes    is_eprv <- function(gene_id) {      grepl("^Slyco_ePRV", gene_id)    }        is_solyc <- function(gene_id) {      grepl("^Solyc", gene_id)    }        # Filter edges to get ePRV-Solyc connections    eprv_solyc_edges <- edge_list[      (is_eprv(edge_list$from) & is_solyc(edge_list$to)) |        (is_solyc(edge_list$from) & is_eprv(edge_list$to)),     ]        if (nrow(eprv_solyc_edges) > 0) {      message(paste0("Found ", nrow(eprv_solyc_edges), " connections between ePRV and Solyc genes"))            # Extract unique Solyc genes connected to ePRV      solyc_connected_to_eprv <- unique(        c(eprv_solyc_edges$from[is_solyc(eprv_solyc_edges$from)],          eprv_solyc_edges$to[is_solyc(eprv_solyc_edges$to)])      )            message(paste0("Identified ", length(solyc_connected_to_eprv),                      " unique Solyc genes connected to ePRV genes"))            # Save the list of Solyc genes connected to ePRV      write.table(solyc_connected_to_eprv,                   paste0(output_prefix, "_Solyc_connected_to_ePRV.txt"),                  row.names = FALSE, col.names = FALSE, quote = FALSE)            # Filter to genes found in GO database      solyc_in_GO <- intersect(solyc_connected_to_eprv, gene2go$gene)            if (length(solyc_in_GO) >= 3) {        # Create gene vector for topGO - with only Solyc genes as universe        solyc_universe <- universe_genes[grepl("^Solyc", universe_genes)]        solyc_universe_in_GO <- intersect(solyc_universe, gene2go$gene)                if (length(solyc_universe_in_GO) > 0) {          geneFac <- geneList(solyc_in_GO, solyc_universe_in_GO)                    # Store results across all ontologies          all_go_results <- list()                    # Set up colors for the ontologies in the combined plot          ont_colors <- c("BP" = "#1f77b4", "MF" = "#ff7f0e", "CC" = "#2ca02c")                    # Create a combined table for all ontologies          combined_results <- data.frame()                    for (ont in ontologies) {            message(paste0("Running GO enrichment for ePRV-Solyc connections [", ont, "]"))                        tryCatch({              GOdata <- new("topGOdata",                            ontology = ont,                            allGenes = geneFac,                            annot = annFUN.gene2GO,                            gene2GO = gene2GOmap,                            nodeSize = 3)                            # Skip if too few genes              if (numGenes(GOdata) < 3) {                message("  Too few genes with GO annotations in this category")                next              }                            resultFisher <- runTest(GOdata, algorithm = "classic", statistic = "fisher")              tab <- GenTable(GOdata, classicFisher = resultFisher,                              orderBy = "classicFisher", topNodes = 30)                            # Add ontology column to the results table              tab$Ontology <- ont                            # Store results              all_go_results[[ont]] <- tab                            # Add to combined results              combined_results <- rbind(combined_results, tab)                            # Save individual ontology results              write.csv(tab,                         paste0(output_prefix, "_GO_", ont, "_ePRV_connected_Solyc.csv"),                         row.names = FALSE)                            # Create individual barplot              pdf(paste0(output_prefix, "_GO_", ont, "_ePRV_connected_Solyc_barplot.pdf"))              barplot(-log10(as.numeric(tab$classicFisher)),                      names.arg = tab$Term, las = 2, cex.names = 0.6,                      col = ont_colors[ont],                      main = paste("GO", ont, "- Solyc genes connected to ePRV"),                      ylab = "-log10(Fisher p-value)")              dev.off()                          }, error = function(e) {              message(paste0("Error in GO enrichment for ePRV connections [", ont, "]: ", e$message))            })          }                    # Save the combined results          if (nrow(combined_results) > 0) {            write.csv(combined_results,                       paste0(output_prefix, "_GO_ALL_ePRV_connected_Solyc.csv"),                       row.names = FALSE)                        # Create a combined plot with the top 10 terms from each ontology            top_terms <- list()                        for (ont in names(all_go_results)) {              if (nrow(all_go_results[[ont]]) > 0) {                # Get top 10 terms or fewer if less than 10 available                n_terms <- min(10, nrow(all_go_results[[ont]]))                top_terms[[ont]] <- all_go_results[[ont]][1:n_terms, ]              }            }                        # Combine top terms from each ontology            all_top_terms <- do.call(rbind, top_terms)                        # Create a factor for sorting the bars by ontology            all_top_terms$Term_Ont <- paste0(all_top_terms$Term, " (", all_top_terms$Ontology, ")")            all_top_terms$Term_Ont <- factor(all_top_terms$Term_Ont,                                              levels = all_top_terms$Term_Ont[order(all_top_terms$Ontology)])                        # Create combined barplot            pdf(paste0(output_prefix, "_GO_Combined_ePRV_connected_Solyc_barplot.pdf"),                 width = 12, height = 8)                        # Prepare the plot data            bp_values <- -log10(as.numeric(all_top_terms$classicFisher))            bp_colors <- ont_colors[all_top_terms$Ontology]                        # Create barplot            par(mar = c(12, 5, 4, 2) + 0.1)  # Increase bottom margin            bp <- barplot(bp_values,                          names.arg = rep("", length(bp_values)),  # Empty names initially                          col = bp_colors,                          main = "GO Enrichment - Solyc genes connected to ePRV",                          ylab = "-log10(Fisher p-value)",                          las = 2)                        # Add term names at an angle            text(bp, -0.5, labels = all_top_terms$Term,                  srt = 45, adj = 1, xpd = TRUE, cex = 0.7)                        # Add legend            legend("topright",                    legend = names(ont_colors),                    fill = ont_colors,                    title = "Ontology",                    bty = "n")                        dev.off()          }        } else {          message("No Solyc genes in the universe match gene IDs in the GO mapping file")        }      } else {        message("Too few Solyc genes connected to ePRV have GO annotations")      }    } else {      message("No connections found between ePRV and Solyc genes")    }  }    # Return useful objects#  return(list(#    moduleColors = moduleColors,#    MEs = MEs,#    geneTree = geneTree,#    kme = kme,#    gene_to_module = gene_to_module#  ))}